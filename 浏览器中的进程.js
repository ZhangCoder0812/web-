/* 

 进程：操作系统分配资源的基本/最小单位，进程包含线程
 线程：由进程所管理 

 浏览器是多进程的，一个页卡挂了 其他页卡也能正常使用
 打开一个页卡就是开了一个进程，代码都是跑在线程中的，


- 浏览器中的5个进程：[进程]
   + 浏览器进程：负责界面显示 用户交互 子进程管理 提供存储
   + 网络进程：加载网络资源[html，js，css]
   + 渲染进程：用于渲染页面[最重要的进程] 每个页卡中都包含 相对独立
   + GPU进程：渲染动画 3d绘制 提高性能
   + 插件进程：chrome中安装的一些插件

   
- 从浏览器输入URL到显示页面发生了什么？

1.请求响应过程
  + 用户输入url地址 会开始导航 输入的若不是url 会使用默认的搜索引擎生成地址 [浏览器进程里面做]
  + 浏览器进程 会准备一个渲染进程用于渲染页面
  + 网络进程加载资源 最终将加载的资源交给渲染进程来处理
  + 渲染完毕显示  

  网络七/四层模型：(物 数)电缆 双绞线 网(ip) 传(tcp udp) (会 表 应)http

  + 先去查找缓存 检查缓存是否过期 有缓存 直接返回中内容
  + 看域名是否被解析过 DNS协议 将域名解析成ip地址 映射表 一个分布式的数据库
    DNS是基于UDP的 [因为每次查询 几级域名之间查询要使用tcp就会有3握4挥 分段传输 速度慢 
                   upd 速度快 但是可能会丢包 查询域名希望速度快 所以使用udp
                   丢包了就再发一次呗 反正速度快 ]
  + 请求若是https 会做SSL协商
  + ip地址来进行寻址 找到对方 ，排队等待 同一时间最多发送6个http请求
  + tcp 创建连接 3握4挥 用于连接
  + 利用tcp传输数据 数据很大 会进行拆包 有序传输 可靠 ，丢包会重发机制
    服务器会按顺序来接受
  + 发送http请求 [请求行 请求头 请求体]                   
  + 发完请求后 tcp链接再http1.1中默认不会断开 keep-alive 为了下次传输数据可以复用
    上次创建的链接
  + 服务器收到数据解析 [请求行 请求头 请求体] -> [响应行 响应头 响应体]  
  + 状态码 301 302 会重定向  重新走上面的流程     
          304 查询浏览器缓存进行缓存

   输入 jd.com 控制台network看到 jd.com返回301/302是因为 访问的时候没有加www
   浏览器帮我们重定向到了www.jd.com 这时候有可能还返回301/302 因为可能是http协议
   帮我们重定位到https协议。所以直接输入 https://www.jd.com 速度最快 不用多余的重
   定向过程
   
   右键Priority查看发送优先级别 还有其他的字段 协议 域名...等
   点击去某个请求 点击Timing 可以看到排队事件 http请求同一时间最多发6个
   ctrl+shift+p 打开layers 查看页面图层

   http历史：
      + http0.9 负责传输html 最早的时候没有请求头，响应头 只能传文本 不能传图片 js css 等
      + http1.0 提供了header 可以根据header的不同传输处理资源 ，每次发完请求会断开tcp链接
      + http1.1 默认开始长链接keep-alive 可以复用链接 一个tcp链接上发送多个http请求。
                为了方式一个请求等待另一个请求发完才使用链路的情况 出现'管线化' 一个域名下最多建立6个tcp链接
                但是服务器处理多个请求 是按顺序返回的 虽然请求是并发的 但是响应还是按顺序一次处理返回 产生'队
                头阻塞'问题 [丢包重新发送 后面一直等待]
      + http2.0 用同一个tcp链接发送数据 一个域名 一个tcp 即'多路复用'    
                头部压缩
                主动推送：服务器可以主动
      + http3.0 解决了tcp的队头阻塞的问题 不用tcp 使用udp + QUIC协议                 
 
2.浏览器接受资源解析过程
 
   css放在body上面：html渲染会先扫描js和css 渲染从上到下 边解析边渲染    
   
   
   渲染dom的时候 要等到css加载完毕
                   link标签不会阻塞dom渲染，dom加载完成 css也差多请求回来 然后渲染页面
                   若是将css放在body下面 可能会导致二次渲染[重绘]
                    则dom加载完成 渲染一次 css请求回来 再渲染一次[重绘] 
                    

*/