 
 #  js 为什么是单线程?
    - js最大的特点就是单线程，也就是说同一时间只能做一件事，与它的用途有关
      js主要用途是与用户互动 操作DOM，这决定了它只能是单线程 否则会产生一
      系列问题。如若是多线程 一个线程想要操作DOM 而一个线程却删除了DOM 这
      就不能确定以哪个线程为准了。
    - js单线程是指主线程是单线程，js可以创建多个子线程。


 # 任务
    - 同步任务：
        在主线程执行的任务，这些任务会按顺序执行，只有在上一个任务结束后，才
        会执行下一个任务。
    - 异步任务：
        不进入主线程，而是进入一个"任务队列"的任务，当主线程中的任务执行完，
        才会从任务队列中取出异步任务放入主线程执行。
      

 # 任务队列
    - 单线程就意味着所有的任务需要排队，前一个任务结束 才会执行后一个任务，
      如果前一个任务耗时很长 后一个任务就要一直等待着。


 # 宏任务 微任务 
     异步任务分为 宏任务 微任务 
    - 宏任务：script(整个js脚本), setTimeout, setIntereval, requestAnimationFrame 
              I/O
    - 微任务：promise的then里面的回调, MutaionObserver()用来监听事件的改变 
             紧跟在async await之后执行任务, catch回调函数, nextTick函数


 # 什么是浏览器的事件轮询？
    - 主线程从"任务队列"中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。
      主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查微任务队列是否为空
     （执行完一个任务的具体标志是函数执行栈为空）,如果不为空则会一次性执行完所有
     微任务队列。然后再进入下一个循环去任务队列中取下一个任务执行。            
   

 # 为什么要有两种任务，为什么引入微任务 只有宏任务可以么？
    - js执行过程中 ，宏任务都是先进先出原则执行，这时若有个优先级较高的任务要执行，
      若只有宏任务就只能再往任务队列离添加一个，根据先进先出的原则 肯定是最后执行
      的。所以只有宏任务是不行的 ，为了处理更高优先级的任务引入了微任务的概念，当
      一个宏任务执行时 将碰到的微任务添加到微任务队列 当这个宏任务执行完毕时 去执
      行微任务队列中的任务 直到微任务队列全部执行完后，再继续下一个宏任务。以此往复。 
      这就是setTimeout可能不准时的原因，因为其中可能在执行微任务            

 # node中的事件循环 和浏览器中的事件循环有什么区别？
    - 宏任务执行顺序：
        1. timers 定时器：执行安排的setTimeout setInterval 中的回调函数
        2. pendding callback 待定回调：执行到下一个循环迭代的I/O回调
        3. idle prepare：仅系统内部使用
        4. poll 轮询：检索新的I/O事件 执行与I/O相关的操作   
        5. check：执行 setImmediate 的回调函数
        6. close callback：socket的关闭
        
    Node中的事件轮询分Node版本  
        - Node V10 之前：
        1. 执行完一个阶段中的所有任务(上述6个)
        2. 执行nextTick队列里的任务
        3. 执行完微任务队列的内容     
        - NodeV10之后和浏览器相同    