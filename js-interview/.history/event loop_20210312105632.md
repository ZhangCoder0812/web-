# js 为什么是单线程?

    - js最大的特点就是单线程，也就是说同一时间只能做一件事，与它的用途有关
      js主要用途是与用户互动 操作DOM，这决定了它只能是单线程 否则会产生一
      系列问题。如若是多线程 一个线程想要操作DOM 而一个线程却删除了DOM 这
      就不能确定以哪个线程为准了。
    - js单线程是指主线程是单线程，js可以创建多个子线程。

# 任务

    - 同步任务：
        在主线程执行的任务，这些任务会按顺序执行，只有在上一个任务结束后，才
        会执行下一个任务。
    - 异步任务：
        不进入主线程，而是进入一个"任务队列"的任务，当主线程中的任务执行完，
        才会从任务队列中取出异步任务放入主线程执行。

# 任务队列

    - 单线程就意味着所有的任务需要排队，前一个任务结束 才会执行后一个任务，
      如果前一个任务耗时很长 后一个任务就要一直等待着。

# 宏任务 微任务

     异步任务分为 宏任务 微任务
    - 宏任务：script(整个js脚本), setTimeout, setIntereval, requestAnimationFrame
              I/O
    - 微任务：promise的then里面的回调, MutaionObserver()用来监听事件的改变
             紧跟在async await之后执行任务, catch回调函数, nextTick函数

# 什么是浏览器的事件轮询？

    - 主线程从"任务队列"中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。
      主线程会不断从任务队列中按顺序取任务执行，每执行完一个任务都会检查微任务队列是否为空
     （执行完一个任务的具体标志是函数执行栈为空）,如果不为空则会一次性执行完所有
     微任务队列。然后再进入下一个循环去任务队列中取下一个任务执行。

# 为什么要有两种任务，为什么引入微任务 只有宏任务可以么？

    - js执行过程中 ，宏任务都是先进先出原则执行，这时若有个优先级较高的任务要执行，
      若只有宏任务就只能再往任务队列离添加一个，根据先进先出的原则 肯定是最后执行
      的。所以只有宏任务是不行的 ，为了处理更高优先级的任务引入了微任务的概念，当
      一个宏任务执行时 将碰到的微任务添加到微任务队列 当这个宏任务执行完毕时 去执
      行微任务队列中的任务 直到微任务队列全部执行完后，再继续下一个宏任务。以此往复。
      这就是setTimeout可能不准时的原因，因为其中可能在执行微任务

# node 中的事件循环 和浏览器中的事件循环有什么区别？

    - 宏任务执行顺序：
        1. timers 定时器：执行安排的setTimeout setInterval 中的回调函数
        2. pendding callback 待定回调：执行到下一个循环迭代的I/O回调
        3. idle prepare：仅系统内部使用
        4. poll 轮询：检索新的I/O事件 执行与I/O相关的操作
        5. check：执行 setImmediate 的回调函数
        6. close callback：socket的关闭

    Node中的事件轮询分Node版本
        - Node V10 之前：(执行完一个阶段的宏任务 清空微任务)
            1. 执行完一个阶段中的所有任务(上述6个)
            2. 执行nextTick队列里的任务
            3. 执行完微任务队列的内容
        - NodeV10之后和浏览器相同

# 什么是事件委托

    - 事件委托也称之为事件代理. 是js中常用绑定事件的常 用技巧。顾名思义，
      “事件代理”即是把原本需要绑定在子元素的响应事件委托给父元素，让父
      元素担当事件监听的职务

    - 举个通俗的例子：比如一个宿舍的同学同时快递到了，一种方法就是他们一个
      个去领取，还有一种方法就是把这件事情委托给宿舍长，让一个人出去拿好
      所有快递，然后再根据收件人一 一分发给每个宿舍同学；

    - 在这里，取快递就是一个事件，每个同学指的是需要响应事件的 DOM 元素，
      而出去统一领取快递的宿舍长就是代理的元素，所以真正绑定事件的是这个
      元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的
      事件应该匹配到被代理元素中的哪一个或者哪几个

# 事件委托的好处

    - 减少事件数量，提高性能
    - 预测未来元素，新添加的元素仍然可以触发该事件
    - 避免内存外泄，在低版本的IE中，防止删除元素而没有移除事件而造成的内存溢出

# 移动端

    - 运行在移动设备上的产品
    - 移动设备：手机(Android/ios) 平版 watch

# H5

    - 响应式HTML页面页面
    - 运行在 移动端浏览器，原生App的WebView

# hyBrid 模式

    - 把H5页面嵌入到原生App中的WebView中，WebView,微信二次开发
      如：微信小程序就是运行在微信的 WebView 中，微信提供一些
          方法供小程序使用，因为微信App能直接操作手机操作系统。

# 对比

    - 原生App：基于手机操作系统，性能好，动画，运行流畅，
              能够对手机内部软硬件之间操作，调取通讯录，摄像头...
              开发成本高，周期长，不能跨平台，IOS7天审核期
              需要用户手动更新

    - webApp/H5 : 性能和速度不是很好，运行在浏览器，
                  不能直接对手机内部软硬件之间操作，
                  除非浏览器提供相应的接口（jsBridge）。
                  自主更新

    - hyBrid：原生App + H5
