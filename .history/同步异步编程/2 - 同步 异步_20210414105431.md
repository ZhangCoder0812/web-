# 任务
    - 同步任务
        在主线程执行的任务，这些任务会被按顺序执行，只有在上一个任务结束之后
        才会执行下一个任务
    - 异步任务
        不进入主线程，而是进入'任务队列'的任务，当主线程任务执行完，才会从任
        务队列中取出异步任务放入到主线程执行。

# 任务队列
    - 单线程就意味着所有的任务需要排队，前一个任务结束，才会执行后一个任务，
      如果前一个任务耗时很长，后一个任务就要一直等着。
      如：死循环 后面的代码一直执行不了 页面一直转圈     


# 同步编程：
        上一个任务/上一段代码没有执行完，下一个任务/下一段代码是不能执行的，同时只能做一件事。
        如：死循环会让后面代码执行不了，死循环一直结束不了任务。

# 异步编程：「单线程异步编程」
       - EventQueue：事件队列/事件池，「存放等待执行的任务」
       - WebApi：监听区域/监听池，「监听哪些任务可以执行」
       - EventLoop：事件轮询机制

       - 宏任务：
            setTimeout/setInterval 定时器
            事件绑定
            ajax/axios/fetch
            MessageChannel
            setImmedia「node」
            requestAnimationFrame 有争议

       - 微任务：
            Promise.then/catch/finally
            async/await 后面的代码
            queueMicrotask「用于创建一个微任务」
            MutationObserver「监听DOM的改变」
            IntersectionObserver「监听元素与当前视口交叉信息 可用于实现图片延迟加载」
            process.nextTick「node中」

# 为什么有两种任务，为什么引入微任务，只有宏任务不行么？
    - JS执行过程中，宏任务都是先进先出的原则执行，这是若有个优先级较高的任务
      要执行，若只有宏任务就执行再往任务队列中添加一个，根据先进先出 就导致这个
      优先级高的任务最后执行。所以只有宏任务肯定是不行的。
    - 为了处理较高优先级的任务而引入微任务的概念，当一个宏任务执行时将碰到的微任务
      添加到任务队列，当这个宏任务执行完毕 再去清空微任务队列中的任务，然后在开继续
      下一个宏任务，以此往复。
        